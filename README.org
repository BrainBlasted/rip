* ⚰ rip (Rm ImProved) ⚰
[[https://crates.io/crates/rm-improved][https://img.shields.io/crates/v/rm-improved.svg]]
[[https://travis-ci.org/nivekuil/rip][https://travis-ci.org/nivekuil/rip.svg?branch=master]]

=rip= is a command-line deletion tool focused on safety, ergonomics, and performance.  It does /not/ implement the xdg-trash spec.

Deleted files get sent to the graveyard (=/tmp/.graveyard= by default) under their absolute path, giving you a chance to recover them.  No data is overwritten.  If files that share the same path are deleted, they will be renamed as numbered backups.

=rip= is made for lazy people.  If any part of the interface could be more intuitive, please open an issue or pull request.

** ⚰ Installation
Get a binary [[https://github.com/nivekuil/rip/releases][release]] (Linux x86_64, ARMv7 and macOS), untar it, and move it somewhere on your $PATH:
#+BEGIN_EXAMPLE
$ tar xvzf rip-*.tar.gz
$ mv rip /usr/local/bin
#+END_EXAMPLE

or build it with a nightly rustc:
#+BEGIN_EXAMPLE
$ cargo install rm-improved
#+END_EXAMPLE
** ⚰ Usage
#+BEGIN_EXAMPLE
USAGE:
    rip [FLAGS] [OPTIONS] [TARGET]...

FLAGS:
    -d, --decompose    Permanently deletes (unlink) the entire graveyard
    -h, --help         Prints help information
    -i, --inspect      Prints some info about TARGET before prompting for action
    -s, --seance       Prints files that were sent under the current directory
    -V, --version      Prints version information

OPTIONS:
        --graveyard <graveyard>    Directory where deleted files go to rest
    -r, --resurrect <target>       Undo the last removal by the current user, or specify some file(s) in the graveyard.  Combine with -s to restore everything printed by -s.

ARGS:
    <TARGET>...    File or directory to remove
#+END_EXAMPLE
Basic usage -- easier than rm
#+BEGIN_EXAMPLE
$ rip dir1/ file1
#+END_EXAMPLE
Undo the last deletion
#+BEGIN_EXAMPLE
$ rip -r
Returned /tmp/.graveyard/home/jack/file1 to /home/jack/file1
#+END_EXAMPLE
Print some info (size and first few lines in a file, total size and first few files in a directory) about the target and then prompt for deletion
#+BEGIN_EXAMPLE
$ rip -i file1
dir1: file, 1337 bytes including:
> Position: Shooting Guard and Small Forward ▪ Shoots: Right
> 6-6, 185lb (198cm, 83kg)
Send file1 to the graveyard? (y/n) y
#+END_EXAMPLE
Print files that were deleted from under the current directory
#+BEGIN_EXAMPLE
$ rip -s
/tmp/.graveyard/home/jack/file1
/tmp/.graveyard/home/jack/dir1
#+END_EXAMPLE
Name conflicts are resolved
#+BEGIN_EXAMPLE
$ touch file1
$ rip file1
$ rip -s
/tmp/.graveyard/home/jack/dir1
/tmp/.graveyard/home/jack/file1
/tmp/.graveyard/home/jack/file1~1
#+END_EXAMPLE
-r also takes the path of a file in the graveyard
#+BEGIN_EXAMPLE
$ rip -r /tmp/.graveyard/home/jack/file1
Returned /tmp/.graveyard/home/jack/file1 to /home/jack/file1
#+END_EXAMPLE
Combine -r and -s to restore everything printed by -s
#+BEGIN_EXAMPLE
$ rip -sr
Returned /tmp/.graveyard/home/jack/dir1 to /home/jack/dir1
Returned /tmp/.graveyard/home/jack/file1~1 to /home/jack/file1~1
#+END_EXAMPLE
** ⚰ Notes
- In general, a deletion followed by a =--resurrect= should be idempotent.
- You probably shouldn't alias =rm= to =rip=.  =rm -r= will also get really confusing.
- If you want to put the graveyard somewhere else (like =~/.local/share/Trash=), you have two options, in order of precedence:
  1. Alias =rip= to =rip --graveyard ~/.local/share/Trash=
  2. Set the environment variable =$GRAVEYARD= to =~/.local/share/Trash=.
  This can be a good idea because if the graveyard is mounted on an in-memory filesystem (as /tmp is in Arch Linux), deleting large files can quickly fill up your RAM.  It's also much slower to move files across filesystems, although the delay should be minimal with an SSD.
- The deletion log is kept in =.record=, found in the top level of the graveyard.
